use lilacc_ast::{token::*, lit::*, *};

grammar;

pub Expr: Expr = {
    Relational,
};

Relational: Expr = {
    <lhs: Add> "<" <rhs: Add> => Expr::Binary(ExprBinary {left: Box::new(lhs), op: BinOp::Lt, right: Box::new(rhs)}),
    <lhs: Add> "<=" <rhs: Add> => Expr::Binary(ExprBinary {left: Box::new(lhs), op: BinOp::Le, right: Box::new(rhs)}),
    <lhs: Add> ">" <rhs: Add> => Expr::Binary(ExprBinary {left: Box::new(rhs), op: BinOp::Lt, right: Box::new(lhs)}),
    <lhs: Add> ">=" <rhs: Add> => Expr::Binary(ExprBinary {left: Box::new(rhs), op: BinOp::Le, right: Box::new(lhs)}),
    Add,
};

Add: Expr = {
    <lhs: Add> "+" < rhs: Mul> => Expr::Binary(ExprBinary {left: Box::new(lhs), op: BinOp::Add, right: Box::new(rhs)}),
    <lhs: Add> "-" < rhs: Mul> => Expr::Binary(ExprBinary {left: Box::new(lhs), op: BinOp::Sub, right: Box::new(rhs)}),
    Mul,
};

Mul: Expr = {
    <lhs: Mul> "*" < rhs: Unary> => Expr::Binary(ExprBinary {left: Box::new(lhs), op: BinOp::Mul, right: Box::new(rhs)}),
    <lhs: Mul> "/" < rhs: Unary> => Expr::Binary(ExprBinary {left: Box::new(lhs), op: BinOp::Div, right: Box::new(rhs)}),
    Unary,
};

Unary: Expr = {
    "-" <p: Primary> => Expr::Unary(ExprUnary {op: UnOp::Neg, expr: Box::new(p)}),
    Primary,
}

Primary: Expr = {
    "Lit" => Expr::Lit(ExprLit {lit: <>}),
    "Ident" => Expr::Ident(ExprIdent {name: <>}),
    "(" <Expr> ")",
};

extern {
    type Location = ();
    type Error = ();

    enum Token {
        "Lit" => Token::Lit(<Lit>),

        "Ident" => Token::Ident(<String>),

        "=" => Token::Eq,
        "<" => Token::Lt,
        "<=" => Token::Le,
        "==" => Token::EqEq,
        "!=" => Token::Ne,
        ">=" => Token::Ge,
        ">" => Token::Gt,
        "&&" => Token::AndAnd,
        "||" => Token::OrOr,
        "!" => Token::Not,

        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,

        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
    }
}